import json
import pki
from hashlib import sha3_256
from ecdsa import SigningKey, VerifyingKey
from secrets import token_hex
from redis import Redis
from flask import Flask, request
from base64 import b64decode, b64encode

SERVER = "127.0.0.1:5000"
DIR = "keys/"
JOURNALISTS = 10

# bootstrap keys
intermediate_verifying_key = pki.verify_root_intermediate()

redis = Redis()
app = Flask(__name__)

@app.route("/")
def index():
    return {"status": "OK"}, 200

@app.route("/journalists", methods=["POST"])
def add_journalist():
	content = request.json
	try:
		assert("journalist_key" in content)
		assert("journalist_sig" in content)
	except:
		return {"status": "KO"}, 400

	journalist_verifying_key = VerifyingKey.from_string(b64decode(content["journalist_key"]), curve=pki.CURVE)
	try:
		journalist_sig = pki.verify_key(intermediate_verifying_key, journalist_verifying_key, None, b64decode(content["journalist_sig"]))
	except:
		return {"status": "KO"}, 400
	journalist_uid = sha3_256(journalist_verifying_key.to_string()).hexdigest()
	redis.sadd("journalists", json.dumps({"journalist_uid": journalist_uid,
										  "journalist_key": b64encode(journalist_verifying_key.to_string()).decode("ascii"),
										  "journalist_sig": b64encode(journalist_sig).decode("ascii")}))
	return {"status": "OK"}, 200

@app.route("/journalists", methods=["GET"])
def get_journalists():
	journalists_list = []
	journalists = redis.smembers("journalists")
	for journalist_json in journalists:
		journalists_list.append(json.loads(journalist_json.decode("ascii")))
	return {"status": "OK", "count": len(journalists), "journalists": journalists_list}, 200

@app.route("/ephemeral_keys", methods=["POST"])
def add_ephemeral_keys():
	content = request.json
	try:
		assert("journalist_uid" in content)
		assert("ephemeral_keys" in content)
	except:
		return {"status": "KO"}, 400

	journalist_uid = content["journalist_uid"]
	journalists = redis.smembers("journalists")
	
	for journalist in journalists:
		journalist_dict = json.loads(journalist.decode("ascii"))
		if journalist_dict["journalist_uid"] == journalist_uid:
			journalist_verifying_key = VerifyingKey.from_string(b64decode(journalist_dict["journalist_key"]), curve=pki.CURVE)
	ephemeral_keys = content["ephemeral_keys"]
	
	for ephemeral_key_dict in ephemeral_keys:
		ephemeral_key = b64decode(ephemeral_key_dict["ephemeral_key"])
		ephemeral_key_verifying_key = VerifyingKey.from_string(ephemeral_key, curve=pki.CURVE)
		ephemeral_sig = b64decode(ephemeral_key_dict["ephemeral_sig"])
		ephemeral_sig = pki.verify_key(journalist_verifying_key, ephemeral_key_verifying_key, None, ephemeral_sig)
		redis.sadd(f"journalist:{journalist_uid}", json.dumps({"ephemeral_key": b64encode(ephemeral_key_verifying_key.to_string()).decode("ascii"),
															   "ephemeral_sig": b64encode(ephemeral_sig).decode("ascii")}))

	return {"status": "OK"}, 200

@app.route("/ephemeral_keys", methods=["GET"])
def get_ephemeral_keys():
	journalists = redis.smembers("journalists")
	ephemeral_keys = []

	for journalist in journalists:
		journalist_dict = json.loads(journalist.decode("ascii"))
		journalist_uid = journalist_dict["journalist_uid"]
		ephemeral_key_dict = json.loads(redis.spop(f"journalist:{journalist_uid}").decode("ascii"))
		ephemeral_key_dict["journalist_uid"] = journalist_uid
		ephemeral_keys.append(ephemeral_key_dict)

	return {"status": "OK", "count": len(ephemeral_keys), "ephemeral_keys": ephemeral_keys}, 200

@app.route("/get_root_key", methods=["GET"])
def get_root_key():

	return {"status": "OK"}, 200

@app.route("/message", methods=["POST"])
def send():
	content = request.json
	try:
		assert("message_ciphertext" in content)
		assert("message_public_key" in content)
		assert("message_challenge" in content)
	except:
		return {"status": "KO"}, 400
	message_dict = {
		# encrypted message
		"message_ciphertext": request.json["message_ciphertext"],
		# gj, public key part of the keypar generated by the sending journalist for every message
		"message_public_key": request.json["message_public_key"],
		# gkj, public part computer using the source public key and the per message secret key
		"message_challenge": request.json["message_challenge"]
	}
	# save the journalist to source reply in redis
	redis.set(f"message:{token_hex(32)}", json.dumps(message_dict))
	return {"status": "OK"}, 200

@app.route("/get_challenges", methods=["GET"])
def get_messages_challenge():
	# SERVER EPHEMERAL CHALLENGE KEY
	request_ephemeral_key = SigningKey.generate(curve=pki.CURVE)
	# generate a challenge id
	challenge_id = token_hex(32)
	# save it in redis as an expiring key
	redis.setex(f"challenge:{challenge_id}", 120, b64encode(request_ephemeral_key.to_string()).decode('ascii'))
	message_server_challenges = []
	# retrieve all the message keys
	message_keys = redis.keys("message:*")
	for message_key in message_keys:
		# retrieve the message and load the json
		message_dict = json.loads(redis.get(message_key).decode('ascii'))
		# calculate the per request per message challenge
		#print(f"msg_chall: {len(b64decode(message_dict['message_challenge']))}")
		message_server_challenge = VerifyingKey.from_public_point(pki.get_shared_secret(VerifyingKey.from_string(b64decode(message_dict["message_challenge"]), curve=pki.CURVE), request_ephemeral_key), curve=pki.CURVE)
		#print(f"msg_server_chall: {len(message_server_challenge.to_string())}")
		message_server_challenges.append(b64encode(message_server_challenge.to_string()).decode('ascii'))

	# return all the message challenges
	# padding to hide the number of meesages to be added later
	response_dict = {"status": "OK", "challenge_id": challenge_id, "message_challenges": message_server_challenges}
	return response_dict, 200

@app.route("/send_responses/<challenge_id>", methods=["POST"])
def send_message_challenges_response(challenge_id):
	# retrieve the challenge secret key from the challenge id in redis
	request_ephemeral_key_bytes = redis.get(f"challenge:{challenge_id}")
	if request_ephemeral_key_bytes is not None:
		# re instantiate the key object for the given challenge id from redis
		request_ephemeral_key = SigningKey.from_string(b64decode(request_ephemeral_key_bytes.decode('ascii')), curve=pki.CURVE)
	else:
		return {"status": "KO"}, 400

	# check that we have some challenges responses back
	try:
		assert("message_challenges_responses" in request.json)
		assert(len(request.json["message_challenges_responses"]) > 0)
	except:
		return {"status": "KO"}, 400

	# calculate the inverse of the per request server key
	inv_server = SigningKey.from_secret_exponent(pki.ec_mod_inverse(request_ephemeral_key), curve=pki.CURVE)

	# fetch all the messages again from redis
	message_keys = redis.keys("message:*")
	messages = []
	for message_key in message_keys:
		# retrieve the message and load the json
		messages.append({"message_id": message_key[8:].decode('ascii'), "message_public_key": json.loads(redis.get(message_key).decode('ascii'))["message_public_key"]})

	# check all the challenges responses
	potential_messages_public_keys = []
	for message_challenge_response in request.json["message_challenges_responses"]:
		potential_messages_public_key = VerifyingKey.from_public_point(pki.get_shared_secret(VerifyingKey.from_string(b64decode(message_challenge_response), curve=pki.CURVE), inv_server), curve=pki.CURVE)
		potential_messages_public_keys.append(b64encode(potential_messages_public_key.to_string()).decode('ascii'))

	# check if any public key in the computed challenge/responses matches any message and return them
	valid_messages = []
	message_public_keys = []
	for message in messages:
		message_public_keys.append(message["message_public_key"])
		for potential_messages_public_key in potential_messages_public_keys:
			if potential_messages_public_key == message["message_public_key"]:
				valid_messages.append(message["message_id"])

	# only one attempt please :)
	redis.delete(f"challenge:{challenge_id}")

	if len(valid_messages) > 0:
		return {"status": "OK", "count": len(valid_messages), "messages": valid_messages}, 200
	else:
		return {"status": "KO"}, 404

@app.route("/message/<message_id>", methods=["GET"])
def get_message(message_id):
	assert(len(message_id) == 64)
	message = redis.get(f"message:{message_id}")
	if message is not None:
		message_dict = json.loads(message.decode('ascii'))
		del message_dict["message_challenge"]
		response = {"status": "OK", "message": message_dict}
		return response, 200
	else:
		return {"status": "KO"}, 404

@app.route("/message/<message_id>", methods=["DELETE"])
def delete_message(message_id):
	assert(len(message_id) == 64)
	res = redis.delete(f"message:{message_id}")
	if res > 0:
		return {"status": "OK"}, 200
	else:
		return {"status": "KO"}, 404